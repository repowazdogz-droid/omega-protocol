<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Omega Spatial Demo — V1</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0e0e0e;
      color: #ddd;
      font-family: system-ui, sans-serif;
    }
    #footer {
      position: fixed;
      bottom: 8px;
      left: 8px;
      font-size: 12px;
      opacity: 0.6;
    }
    #ui {
      position: fixed;
      top: 12px;
      left: 12px;
      background: rgba(20, 20, 20, 0.75);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1.4;
      backdrop-filter: blur(6px);
      user-select: none;
    }
    #ui .ui-title {
      font-size: 12px;
      letter-spacing: 0.06em;
      opacity: 0.75;
      margin-bottom: 6px;
      text-transform: uppercase;
    }
    #ui label {
      display: block;
      margin: 6px 0;
      cursor: pointer;
    }
    #ui input {
      margin-right: 8px;
    }
    #inspector {
      position: fixed;
      top: 12px;
      right: 12px;
      width: 280px;
      max-width: calc(100vw - 24px);
      background: rgba(20, 20, 20, 0.75);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1.4;
      backdrop-filter: blur(6px);
    }
    #inspector .insp-title {
      font-size: 12px;
      letter-spacing: 0.06em;
      opacity: 0.75;
      margin-bottom: 6px;
      text-transform: uppercase;
    }
    #inspector .insp-body {
      opacity: 0.92;
    }
    .insp-row {
      margin: 8px 0;
    }
    .insp-label {
      opacity: 0.65;
      font-size: 12px;
    }
    .insp-value {
      margin-top: 2px;
    }
    .insp-callout {
      margin-top: 10px;
      padding: 8px;
      border-radius: 8px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.08);
      opacity: 0.9;
    }
    #header {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      padding: 8px 10px;
      z-index: 10;
      pointer-events: none;
    }
    .h-title {
      font-size: 14px;
      letter-spacing: 0.02em;
      opacity: 0.95;
    }
    .h-sub {
      font-size: 12px;
      opacity: 0.65;
      margin-top: 2px;
    }
    #resetView {
      margin-top: 8px;
      pointer-events: auto;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.12);
      color: #ddd;
      padding: 6px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
    }
    #resetView:hover {
      background: rgba(255,255,255,0.10);
    }
  </style>
</head>
<body>

<div id="footer">
  Human-led. Non-autonomous. Visual reasoning only.<br/>
  Conceptual visualization — no control, no simulation.
</div>

<div id="header">
  <div class="h-title">Omega Spatial Demo (V1)</div>
  <div class="h-sub">Conceptual workspace visualization — no control, no simulation</div>
  <button id="resetView">Reset View</button>
</div>

<div id="ui">
  <div class="ui-title">Layers</div>
  <label><input type="checkbox" id="toggle-structure" checked> Structure</label>
  <label><input type="checkbox" id="toggle-constraints" checked> Constraints</label>
  <label><input type="checkbox" id="toggle-uncertainty" checked> Uncertainty</label>
</div>

<div id="inspector">
  <div class="insp-title">Inspector</div>
  <div id="insp-body" class="insp-body">
    Click an element to inspect.
  </div>
</div>

<script type="module">
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
  import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

  // Scene
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0e0e0e);

  // Camera
  const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.set(4, 4, 6);

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.target.set(0, 1, 0);

  // --- Reset View (camera only) ---
  const resetBtn = document.getElementById("resetView");
  resetBtn.addEventListener("click", () => {
    camera.position.set(4, 4, 6);
    controls.target.set(0, 1, 0);
    controls.update();
  });

  // Lights
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);

  const directional = new THREE.DirectionalLight(0xffffff, 0.6);
  directional.position.set(5, 10, 5);
  scene.add(directional);

  // Grid (reference frame)
  const grid = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
  scene.add(grid);

  // --- Abstract Robot Arm (STRUCTURE ONLY) ---

  const structureGroup = new THREE.Group();
  structureGroup.name = "Structure";

  // Materials
  const baseMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
  const linkMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
  const effectorMat = new THREE.MeshStandardMaterial({ color: 0x66ccff });

  // Base
  const base = new THREE.Mesh(
    new THREE.CylinderGeometry(0.4, 0.4, 0.2, 32),
    baseMat
  );
  base.position.y = 0.1;
  structureGroup.add(base);

  // Link 1
  const link1 = new THREE.Mesh(
    new THREE.BoxGeometry(0.3, 1.2, 0.3),
    linkMat
  );
  link1.position.y = 0.8;
  structureGroup.add(link1);

  // Link 2
  const link2 = new THREE.Mesh(
    new THREE.BoxGeometry(0.25, 1.0, 0.25),
    linkMat
  );
  link2.position.y = 1.9;
  structureGroup.add(link2);

  // End effector (marker only)
  const effector = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 24, 24),
    effectorMat
  );
  effector.position.y = 2.6;
  structureGroup.add(effector);

  // Add to scene
  scene.add(structureGroup);

  // --- Workspace Reach Envelope (CONCEPTUAL) ---

  const reachGroup = new THREE.Group();
  reachGroup.name = "ReachEnvelope";

  const reachMaterial = new THREE.MeshStandardMaterial({
    color: 0x00ff88,
    transparent: true,
    opacity: 0.15,
    depthWrite: false
  });

  // Simple cylindrical reach volume
  const reachVolume = new THREE.Mesh(
    new THREE.CylinderGeometry(1.5, 1.5, 3.0, 32),
    reachMaterial
  );
  reachVolume.position.y = 1.5;
  reachGroup.add(reachVolume);

  // Add to scene
  scene.add(reachGroup);

  // --- Constraints Layer (STATIC, VISUAL ONLY) ---

  const constraintsGroup = new THREE.Group();
  constraintsGroup.name = "Constraints";

  // Materials
  const limitMat = new THREE.LineBasicMaterial({ color: 0xffcc00 });
  const collisionMat = new THREE.MeshStandardMaterial({
    color: 0xff4444,
    transparent: true,
    opacity: 0.18,
    depthWrite: false
  });
  const safetyMat = new THREE.MeshStandardMaterial({
    color: 0xffcc00,
    transparent: true,
    opacity: 0.10,
    depthWrite: false
  });

  // Helper: create a simple arc line in XZ plane
  function makeArc(radius, y, startAngle, endAngle, segments = 48) {
    const points = [];
    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const a = startAngle + (endAngle - startAngle) * t;
      points.push(new THREE.Vector3(
        Math.cos(a) * radius,
        y,
        Math.sin(a) * radius
      ));
    }
    const geom = new THREE.BufferGeometry().setFromPoints(points);
    return new THREE.Line(geom, limitMat);
  }

  // Joint limit arcs (illustrative only)
  const arc1 = makeArc(0.9, 0.35, -Math.PI * 0.6, Math.PI * 0.6);
  const arc2 = makeArc(0.7, 1.45, -Math.PI * 0.45, Math.PI * 0.45);
  const arc3 = makeArc(0.5, 2.25, -Math.PI * 0.35, Math.PI * 0.35);

  constraintsGroup.add(arc1, arc2, arc3);

  // Collision zones (static "do not enter" volumes)
  const collisionZone1 = new THREE.Mesh(
    new THREE.BoxGeometry(0.9, 0.6, 0.9),
    collisionMat
  );
  collisionZone1.position.set(1.1, 0.4, 0.2);
  constraintsGroup.add(collisionZone1);

  const collisionZone2 = new THREE.Mesh(
    new THREE.BoxGeometry(0.7, 0.7, 0.7),
    collisionMat
  );
  collisionZone2.position.set(-1.0, 1.2, -0.6);
  constraintsGroup.add(collisionZone2);

  // Safety buffer zones (soft exclusion / conservative space)
  const safetyBuffer = new THREE.Mesh(
    new THREE.CylinderGeometry(2.0, 2.0, 0.3, 48),
    safetyMat
  );
  safetyBuffer.position.y = 0.15;
  constraintsGroup.add(safetyBuffer);

  // Add to scene
  scene.add(constraintsGroup);

  // --- Uncertainty Layer (STATIC, VISUAL ONLY) ---

  const uncertaintyGroup = new THREE.Group();
  uncertaintyGroup.name = "Uncertainty";

  const uncertaintyMat = new THREE.MeshStandardMaterial({
    color: 0x6688ff,
    transparent: true,
    opacity: 0.10,
    depthWrite: false
  });

  // Unknown region volume 1 (e.g., sensor coverage unknown)
  const unknownRegion1 = new THREE.Mesh(
    new THREE.SphereGeometry(0.7, 32, 32),
    uncertaintyMat
  );
  unknownRegion1.position.set(0.9, 1.8, -0.8);
  uncertaintyGroup.add(unknownRegion1);

  // Unknown region volume 2 (e.g., assumption-based clearance)
  const unknownRegion2 = new THREE.Mesh(
    new THREE.BoxGeometry(1.0, 0.8, 0.6),
    uncertaintyMat
  );
  unknownRegion2.position.set(-0.6, 2.0, 0.9);
  uncertaintyGroup.add(unknownRegion2);

  // Add to scene
  scene.add(uncertaintyGroup);

  // --- Layer Toggles (UI) ---
  const elStructure = document.getElementById("toggle-structure");
  const elConstraints = document.getElementById("toggle-constraints");
  const elUncertainty = document.getElementById("toggle-uncertainty");

  elStructure.addEventListener("change", () => {
    structureGroup.visible = elStructure.checked;
  });

  elConstraints.addEventListener("change", () => {
    constraintsGroup.visible = elConstraints.checked;
  });

  elUncertainty.addEventListener("change", () => {
    uncertaintyGroup.visible = elUncertainty.checked;
  });

  // --- Selection + Inspector (STATIC, DESCRIPTIVE) ---

  const inspBody = document.getElementById("insp-body");

  function setInspector(data) {
    if (!data) {
      inspBody.innerHTML = "Click an element to inspect.";
      return;
    }
    inspBody.innerHTML = `
      <div class="insp-row">
        <div class="insp-label">Element</div>
        <div class="insp-value">${data.name}</div>
      </div>
      <div class="insp-row">
        <div class="insp-label">Layer</div>
        <div class="insp-value">${data.layer}</div>
      </div>
      <div class="insp-row">
        <div class="insp-label">Status</div>
        <div class="insp-value">${data.status}</div>
      </div>
      <div class="insp-callout">${data.callout}</div>
    `;
  }

  // Assign names + metadata to selectable objects
  function tagObject(obj, meta) {
    obj.userData.omegaMeta = meta;
    obj.name = meta.name;
  }

  // Tag Structure objects
  tagObject(base, {
    name: "Base",
    layer: "Structure",
    status: "Known",
    callout: "This is structural geometry. It is descriptive, not a command."
  });
  tagObject(link1, {
    name: "Link 1",
    layer: "Structure",
    status: "Known",
    callout: "Structure is shown for reasoning. No actuation is implied."
  });
  tagObject(link2, {
    name: "Link 2",
    layer: "Structure",
    status: "Known",
    callout: "This representation is abstracted and non-operational."
  });
  tagObject(effector, {
    name: "End Effector Marker",
    layer: "Structure",
    status: "Known",
    callout: "Marker only. This demo does not compute motion or actions."
  });

  // Tag Constraints objects
  tagObject(collisionZone1, {
    name: "Collision Zone A",
    layer: "Constraints",
    status: "Known",
    callout: "This region is excluded for safety reasoning, not optimized for performance."
  });
  tagObject(collisionZone2, {
    name: "Collision Zone B",
    layer: "Constraints",
    status: "Known",
    callout: "Static exclusion zone. No planning or avoidance is computed."
  });
  tagObject(safetyBuffer, {
    name: "Safety Buffer",
    layer: "Constraints",
    status: "Conservative",
    callout: "Conservative buffer shown as a constraint, not an instruction."
  });

  // Tag Uncertainty objects
  tagObject(unknownRegion1, {
    name: "Unknown Region 1",
    layer: "Uncertainty",
    status: "Unknown",
    callout: "This area represents incomplete knowledge, not a detected error."
  });
  tagObject(unknownRegion2, {
    name: "Unknown Region 2",
    layer: "Uncertainty",
    status: "Assumed",
    callout: "Assumption-based region. Confidence depends on missing context."
  });

  // Raycast selection setup
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  let selected = null;
  let selectedOriginalEmissive = null;

  function clearSelection() {
    if (selected && selected.material && "emissive" in selected.material) {
      selected.material.emissive.setHex(selectedOriginalEmissive);
    }
    selected = null;
    selectedOriginalEmissive = null;
    setInspector(null);
  }

  function selectObject(obj) {
    clearSelection();

    selected = obj;
    if (selected.material && "emissive" in selected.material) {
      selectedOriginalEmissive = selected.material.emissive.getHex();
      selected.material.emissive.setHex(0x222222);
    }

    const meta = selected.userData.omegaMeta;
    setInspector(meta || null);
  }

  // Collect selectable objects (only those with omegaMeta)
  function getSelectableObjects() {
    const all = [];
    scene.traverse((obj) => {
      if (obj.userData && obj.userData.omegaMeta) all.push(obj);
    });
    return all;
  }

  renderer.domElement.addEventListener("pointerdown", (event) => {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(getSelectableObjects(), false);

    if (intersects.length === 0) {
      clearSelection();
      return;
    }
    selectObject(intersects[0].object);
  });

  // Resize handling
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Render loop (camera only)
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }

  animate();
</script>

</body>
</html>

